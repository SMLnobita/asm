# Hướng dẫn lập trình Assembly RISC-V

## Mục lục
1. [Giới thiệu](#giới-thiệu)
2. [Bài 1: Đếm từ 0-32 với LED 7 đoạn](#bài-1-đếm-từ-0-32-với-led-7-đoạn)
3. [Bài 2: Điều khiển LED dịch trái/phải](#bài-2-điều-khiển-led-dịch-tráiphải)
4. [Bài 3: Giải mã Switch sang LED 7 đoạn](#bài-3-giải-mã-switch-sang-led-7-đoạn)
5. [Phụ lục: Các kiến thức cần thiết](#phụ-lục-các-kiến-thức-cần-thiết)

## Giới thiệu

Tài liệu này hướng dẫn cách lập trình Assembly RISC-V cho ba ứng dụng cơ bản:
- Đếm và hiển thị trên LED 7 đoạn
- Điều khiển dịch chuyển các LED
- Giải mã giá trị switch sang LED 7 đoạn

Mỗi bài tập đều yêu cầu hiểu biết về:
- Cách tổ chức mã Assembly RISC-V
- Cách tương tác với phần cứng thông qua I/O mapped memory
- Xử lý bit và dữ liệu số trong RISC-V

## Bài 1: Đếm từ 0-32 với LED 7 đoạn

### Yêu cầu
Viết chương trình đếm từ 0-32 với phím KEY1 và KEY2 để điều khiển tăng/giảm, hiển thị kết quả trên LED 7 đoạn HEX0 và HEX1.

### Phân tích bài toán
1. Theo dõi trạng thái của nút nhấn KEY1 (tăng) và KEY2 (giảm)
2. Cập nhật biến đếm (tăng/giảm) dựa vào nút nhấn
3. Giới hạn biến đếm trong khoảng 0-32
4. Chuyển đổi biến đếm thành hàng chục và hàng đơn vị
5. Tra cứu mã LED 7 đoạn tương ứng và hiển thị

### Mã nguồn

```assembly
.section .text
.equ KEY, 0xFF200050
.equ HEX3_HEX0, 0xFF200020

.global _start
_start:
    ################################################################
    #                     Khởi tạo thanh ghi
    ################################################################
    # s1 = KEY (địa chỉ cổng I/O cho nút nhấn)
    la s1, KEY
    
    # s2 = địa chỉ nhãn SEVEN_SEG_DECODE_TABLE 
    la s2, SEVEN_SEG_DECODE_TABLE
    # s3 = 0
    mv s3, x0
LOOP:
    ################################################################
    #                     Đặt các hằng số tạm
    ################################################################
    mv t0, x0     # t0 = zero
    li t1, 2      # t1 = 0x2 (bitmask cho KEY1)
    li t3, 4      # t3 = 0x4 (bitmask cho KEY2)
    li t4, 32     # t4 = 32 (giá trị tối đa)
    li t5, 10     # t5 = 10 (để chia lấy hàng chục)

    # s6 = địa chỉ nhãn HEX_SEGMENTS
    la s6, HEX_SEGMENTS

CHECK_KEY:
    ################################################################
    #           Chờ nhấn phím: đọc halfword từ địa chỉ KEY
    ################################################################
    lh t6, 0(s1)                # t6 = giá trị của KEY
    beq t6, x0, CHECK_KEY       # nếu t6 == 0 thì nhảy tới nhãn CHECK_KEY
WAIT:
    # Chờ nhả phím
    lh a7, 0(s1)                # a7 = giá trị của KEY
    bne a7, x0, WAIT            # nếu a7 != 0 thì nhảy tới nhãn WAIT

    andi t6, t6, 0x6            # Lọc chỉ bit 1 và 2 (KEY1 và KEY2)

KEY_DECODE:
    ################################################################
    #     Kiểm tra từng bit (KEY1, KEY2) và tăng/giảm biến đếm
    ################################################################
    # Kiểm tra KEY1
    and a0, t6, t1
    beq a0, t1, CONG            # Nếu nhấn KEY1 → tăng
    # Kiểm tra KEY2
    and a0, t6, t3
    beq a0, t3, TRU             # Nếu nhấn KEY2 → giảm
    j CHECK_KQ
CONG:
    addi s3, s3, 1
    j CHECK_KQ
TRU:
    addi s3, s3, -1
CHECK_KQ:
    bgt s3, t4, RESET_TO_ZERO
    blt s3, x0, RESET_TO_MAX
    j CONVERT_TO_DECIMAL
RESET_TO_ZERO:
    li s3, 0
    j CONVERT_TO_DECIMAL
RESET_TO_MAX:
    li s3, 32
    j CONVERT_TO_DECIMAL
CONVERT_TO_DECIMAL:
    mv t6, s3                   # t6 = s3 (sao chép biến đếm)
    li a7, 0                    # a7 = 0 (hàng chục)
DIV_LOOP:
    blt t6, t5, DIV_DONE        # Nếu t6 < 10, kết thúc vòng lặp
    sub t6, t6, t5              # t6 = t6 - 10
    addi a7, a7, 1              # a7 = a7 + 1 (tăng hàng chục)
    j DIV_LOOP                  # Lặp lại
DIV_DONE:
SEVEN_SEG_DECODER:
    # Xử lý hàng đơn vị
    mv a0, t6                   # a0 = t6 (hàng đơn vị)
    jal GET_PATTERN             # Gọi hàm lấy pattern
    mv a2, a0                   # a2 = pattern cho hàng đơn vị
    sb a2, 0(s6)                # Lưu byte vào vị trí đầu tiên của HEX_SEGMENTS
    
    # Xử lý hàng chục
    mv a0, a7                   # a0 = a7 (hàng chục)
    jal GET_PATTERN             # Gọi hàm lấy pattern
    mv a2, a0                   # a2 = pattern cho hàng chục
    sb a2, 1(s6)                # Lưu byte vào vị trí thứ hai của HEX_SEGMENTS
    
    lw a2, 0(s6)                # Đọc 1 word từ HEX_SEGMENTS
    la a3, HEX3_HEX0            # a3 = địa chỉ HEX3_HEX0
    sw a2, 0(a3)                # Lưu word vào địa chỉ HEX3_HEX0
    j LOOP                      # Quay lại vòng lặp LOOP

GET_PATTERN:
    # a0 = chỉ số (0-9)
    la t0, SEVEN_SEG_DECODE_TABLE # t0 = địa chỉ bảng
    add t0, t0, a0              # t0 = t0 + a0 (địa chỉ của pattern)
    lb a0, 0(t0)                # a0 = pattern tại địa chỉ t0
    jr ra                       # Trở về (không phải j LOOP)

################################################################
#                         Vùng dữ liệu
################################################################
.section .data
.skip 3
N:
    .byte 16

SEVEN_SEG_DECODE_TABLE:
    .byte 0b00111111, 0b00000110, 0b01011011, 0b01001111
    .byte 0b01100110, 0b01101101, 0b01111101, 0b00000111
    .byte 0b01111111, 0b01100111, 0b00000000, 0b00000000
    .byte 0b00000000, 0b00000000, 0b00000000, 0b00000000

# cấp phát 1 word (4 byte) giá trị 0
HEX_SEGMENTS:
    .word 0

.end
```

### Giải thích chi tiết

1. **Khởi tạo:**
   - Định nghĩa các địa chỉ I/O: KEY và HEX3_HEX0
   - Khởi tạo biến đếm s3 = 0

2. **Vòng lặp chính:**
   - Thiết lập các hằng số: bitmask KEY, giá trị giới hạn, hằng số chia
   - Chờ nhấn phím, sau đó chờ nhả phím (chống dội phím)
   - Xác định phím nào được nhấn (KEY1 hoặc KEY2)

3. **Xử lý phím:**
   - KEY1: Tăng biến đếm
   - KEY2: Giảm biến đếm
   - Kiểm tra giới hạn: 0 ≤ biến đếm ≤ 32

4. **Chuyển đổi thành thập phân:**
   - Chia biến đếm cho 10 để lấy hàng chục và đơn vị
   - Sử dụng vòng lặp trừ thay vì phép chia (RISC-V RV32I không có lệnh chia)

5. **Hiển thị trên LED 7 đoạn:**
   - Tra cứu mã LED 7 đoạn cho hàng đơn vị và hàng chục
   - Kết hợp mã và ghi vào thanh ghi HEX3_HEX0

## Bài 2: Điều khiển LED dịch trái/phải

### Yêu cầu
Viết chương trình thực hiện các chức năng:
- Nhấn KEY1: LED17:0 dịch sang trái
- Nhấn KEY2: LED9:0 dịch sang phải
- Nhấn KEY3: Lấy giá trị từ SW9:0 đưa lên LED17:0

### Phân tích bài toán
1. Theo dõi trạng thái các nút nhấn KEY1, KEY2, KEY3
2. Thực hiện xử lý bit tương ứng với mỗi nút nhấn:
   - Dịch trái toàn bộ 18 bit
   - Dịch phải 10 bit thấp
   - Đọc và hiển thị giá trị switch

### Mã nguồn

```assembly
.section .text
.equ KEY, 0xFF200050          # Địa chỉ của nút nhấn KEY
.equ LEDR, 0xFF200000         # Địa chỉ của LED đỏ (LED17:0)
.equ SW, 0xFF200040           # Địa chỉ của switch (SW9:0)

.global _start
_start:
    ################################################################
    #                     Khởi tạo thanh ghi
    ################################################################
    # s1 = địa chỉ KEY
    la s1, KEY
    
    # s2 = địa chỉ LEDR
    la s2, LEDR
    
    # s3 = địa chỉ SW
    la s3, SW
    
    # s4 = giá trị hiện tại của LED, khởi tạo là 1
    li s4, 1                  # Bắt đầu với bit thấp nhất được bật (0...001)
    
    # Lưu giá trị ban đầu vào LED
    sw s4, 0(s2)

LOOP:
    ################################################################
    #                     Đặt các hằng số tạm
    ################################################################
    li t1, 2                  # t1 = 0x2 (bitmask cho KEY1, 0b10)
    li t2, 4                  # t2 = 0x4 (bitmask cho KEY2, 0b100)
    li t3, 8                  # t3 = 0x8 (bitmask cho KEY3, 0b1000)
    li t4, 0x3FFFF            # t4 = bitmask cho LED17:0 (18 bit)
    li t5, 0x3FF              # t5 = bitmask cho LED9:0 (10 bit)

CHECK_KEY:
    ################################################################
    #           Chờ nhấn phím: đọc halfword từ địa chỉ KEY
    ################################################################
    lh t6, 0(s1)              # t6 = giá trị của KEY
    beq t6, x0, CHECK_KEY     # nếu t6 == 0 thì nhảy tới CHECK_KEY

WAIT:
    # Chờ nhả phím
    lh a7, 0(s1)              # a7 = giá trị của KEY
    bne a7, x0, WAIT          # nếu a7 != 0 thì nhảy tới WAIT

KEY_DECODE:
    ################################################################
    #     Kiểm tra từng bit KEY và thực hiện chức năng tương ứng
    ################################################################
    # Kiểm tra KEY1 - Dịch trái LED17:0
    and a0, t6, t1
    beq a0, t1, SHIFT_LEFT
    
    # Kiểm tra KEY2 - Dịch phải LED9:0
    and a0, t6, t2
    beq a0, t2, SHIFT_RIGHT
    
    # Kiểm tra KEY3 - Đọc giá trị SW9:0 vào LED17:0
    and a0, t6, t3
    beq a0, t3, READ_SWITCH
    
    j DISPLAY_LED             # Nếu không nhấn phím nào, hiển thị LED hiện tại

SHIFT_LEFT:
    ################################################################
    #     Dịch trái LED17:0 (nhân 2) và đảm bảo nằm trong 18 bit
    ################################################################
    slli s4, s4, 1            # Dịch trái 1 bit (nhân 2)
    and s4, s4, t4            # Giữ chỉ 18 bit thấp nhất (LED17:0)
    
    # Nếu tất cả LED đều tắt sau khi dịch, đặt lại bit thấp nhất
    bne s4, x0, DISPLAY_LED   # Nếu s4 != 0, hiển thị LED hiện tại
    li s4, 1                  # Nếu s4 == 0, đặt lại bit thấp nhất (0...001)
    j DISPLAY_LED

SHIFT_RIGHT:
    ################################################################
    #     Dịch phải LED9:0 (chia 2) và đảm bảo nằm trong 10 bit
    ################################################################
    # Tách phần LED9:0 (10 bit thấp)
    and a0, s4, t5            # a0 = s4 & 0x3FF (10 bit thấp)
    
    # Dịch phải phần LED9:0
    srli a0, a0, 1            # Dịch phải 1 bit (chia 2)
    
    # Xóa 10 bit thấp của s4 và giữ phần LED17:10
    li a1, 0xFFFFFC00         # a1 = ~0x3FF (bitmask để giữ bit 10-31)
    and s4, s4, a1            # s4 = s4 & ~0x3FF (xóa 10 bit thấp)
    
    # Kết hợp phần LED17:10 với phần LED9:0 đã dịch
    or s4, s4, a0             # s4 = s4 | a0 (kết hợp)
    
    # Nếu 10 bit thấp đều bằng 0, đặt bit cao nhất của phần 10 bit
    and a0, s4, t5            # Kiểm tra 10 bit thấp
    bne a0, x0, DISPLAY_LED   # Nếu có bit nào bật, hiển thị LED hiện tại
    ori s4, s4, 0x200         # Nếu tất cả bit thấp tắt, bật bit thứ 9 (0x200)
    j DISPLAY_LED

READ_SWITCH:
    ################################################################
    #     Đọc giá trị từ SW9:0 đưa lên LED17:0
    ################################################################
    lw a0, 0(s3)              # Đọc giá trị từ SW
    and s4, a0, t5            # Chỉ lấy 10 bit thấp (SW9:0)
    j DISPLAY_LED

DISPLAY_LED:
    ################################################################
    #     Hiển thị giá trị trên LED
    ################################################################
    sw s4, 0(s2)              # Ghi giá trị s4 vào địa chỉ LED
    j LOOP                    # Quay lại vòng lặp chính

.end
```

### Giải thích chi tiết

1. **Khởi tạo:**
   - Định nghĩa các địa chỉ I/O: KEY, LEDR và SW
   - Khởi tạo giá trị LED s4 = 1 (bật LED0)

2. **Vòng lặp chính:**
   - Thiết lập các bitmask: bitmask KEY và bitmask LED
   - Đợi phím nhấn và thực hiện chức năng tương ứng

3. **Các chức năng chính:**
   - **Dịch trái LED17:0 (KEY1):**
     - Sử dụng lệnh `slli` để dịch trái 1 bit
     - Giữ kết quả trong phạm vi 18 bit
     - Nếu tất cả đều tắt, đặt lại bit thấp nhất

   - **Dịch phải LED9:0 (KEY2):**
     - Tách, dịch và kết hợp lại các phần của thanh ghi
     - Xử lý riêng 10 bit thấp và các bit cao hơn
     - Nếu tất cả bit thấp đều tắt, đặt lại bit cao nhất của 10 bit thấp

   - **Đọc giá trị switch (KEY3):**
     - Đọc giá trị từ địa chỉ SW
     - Lấy 10 bit thấp và hiển thị lên LED

4. **Hiển thị LED:**
   - Ghi giá trị thanh ghi s4 vào địa chỉ LEDR

## Bài 3: Giải mã Switch sang LED 7 đoạn

### Yêu cầu
Viết chương trình giải mã:
- SW3:0 ra LED 7 đoạn HEX0
- SW7:4 ra LED 7 đoạn HEX1
- SW11:8 ra LED 7 đoạn HEX2
- SW15:12 ra LED 7 đoạn HEX3

### Phân tích bài toán
1. Đọc giá trị từ các switch (SW)
2. Tách từng nhóm 4 bit
3. Tra cứu mã LED 7 đoạn tương ứng
4. Kết hợp các mã và hiển thị trên LED 7 đoạn

### Mã nguồn

```assembly
.section .text
.equ SW, 0xFF200040            # Địa chỉ của switch (SW)
.equ HEX3_HEX0, 0xFF200020     # Địa chỉ của LED 7 đoạn HEX3-HEX0

.global _start
_start:
    ################################################################
    #                     Khởi tạo thanh ghi
    ################################################################
    # s1 = địa chỉ SW
    la s1, SW
    
    # s2 = địa chỉ HEX3_HEX0
    la s2, HEX3_HEX0
    
    # s3 = địa chỉ bảng giải mã 7 đoạn
    la s3, SEVEN_SEG_DECODE_TABLE

MAIN_LOOP:
    ################################################################
    #                     Đọc giá trị từ switch
    ################################################################
    # Đọc giá trị switch
    lw s4, 0(s1)               # s4 = giá trị từ SW
    
    ################################################################
    #                     Tách từng nhóm 4 bit
    ################################################################
    # Tách SW3:0 cho HEX0
    andi t0, s4, 0xF           # t0 = s4 & 0xF (4 bit thấp nhất)
    
    # Tách SW7:4 cho HEX1
    srli t1, s4, 4             # Dịch phải 4 bit
    andi t1, t1, 0xF           # t1 = (s4 >> 4) & 0xF (4 bit kế tiếp)
    
    # Tách SW11:8 cho HEX2
    srli t2, s4, 8             # Dịch phải 8 bit
    andi t2, t2, 0xF           # t2 = (s4 >> 8) & 0xF (4 bit tiếp theo)
    
    # Tách SW15:12 cho HEX3
    srli t3, s4, 12            # Dịch phải 12 bit
    andi t3, t3, 0xF           # t3 = (s4 >> 12) & 0xF (4 bit cao nhất)
    
    ################################################################
    #                     Giải mã và hiển thị
    ################################################################
    # Giải mã giá trị cho HEX0, HEX1, HEX2, HEX3
    mv a0, x0                  # Khởi tạo kết quả = 0
    
    # Giải mã HEX0 (SW3:0)
    add t4, s3, t0             # t4 = s3 + t0 (địa chỉ trong bảng mã)
    lb t4, 0(t4)               # t4 = giá trị 7 đoạn cho t0
    or a0, a0, t4              # a0 = a0 | t4 (đặt pattern HEX0)
    
    # Giải mã HEX1 (SW7:4)
    add t4, s3, t1             # t4 = s3 + t1 (địa chỉ trong bảng mã)
    lb t4, 0(t4)               # t4 = giá trị 7 đoạn cho t1
    slli t4, t4, 8             # t4 = t4 << 8 (dịch sang vị trí HEX1)
    or a0, a0, t4              # a0 = a0 | t4 (đặt pattern HEX1)
    
    # Giải mã HEX2 (SW11:8)
    add t4, s3, t2             # t4 = s3 + t2 (địa chỉ trong bảng mã)
    lb t4, 0(t4)               # t4 = giá trị 7 đoạn cho t2
    slli t4, t4, 16            # t4 = t4 << 16 (dịch sang vị trí HEX2)
    or a0, a0, t4              # a0 = a0 | t4 (đặt pattern HEX2)
    
    # Giải mã HEX3 (SW15:12)
    add t4, s3, t3             # t4 = s3 + t3 (địa chỉ trong bảng mã)
    lb t4, 0(t4)               # t4 = giá trị 7 đoạn cho t3
    slli t4, t4, 24            # t4 = t4 << 24 (dịch sang vị trí HEX3)
    or a0, a0, t4              # a0 = a0 | t4 (đặt pattern HEX3)
    
    # Hiển thị kết quả trên HEX3-HEX0
    sw a0, 0(s2)               # Ghi giá trị vào địa chỉ HEX3_HEX0
    
    # Vòng lặp liên tục để cập nhật hiển thị
    j MAIN_LOOP                # Quay lại vòng lặp chính

################################################################
#                         Bảng giải mã 7 đoạn
################################################################
.section .data
SEVEN_SEG_DECODE_TABLE:
    .byte 0b00111111, 0b00000110, 0b01011011, 0b01001111
    .byte 0b01100110, 0b01101101, 0b01111101, 0b00000111
    .byte 0b01111111, 0b01100111, 0b00000000, 0b00000000
    .byte 0b00000000, 0b00000000, 0b00000000, 0b00000000

.end
```

### Giải thích chi tiết

1. **Khởi tạo:**
   - Định nghĩa các địa chỉ I/O: SW và HEX3_HEX0
   - Lấy địa chỉ bảng giải mã 7 đoạn

2. **Vòng lặp chính:**
   - Đọc giá trị từ switch (SW)
   - Tách từng nhóm 4 bit bằng cách dịch và AND với bitmask

3. **Xử lý từng nhóm 4 bit:**
   - Sử dụng các phép thao tác bit để tách SW3:0, SW7:4, SW11:8, SW15:12
   - Tra cứu mã LED 7 đoạn tương ứng bằng cách truy cập bảng mã

4. **Hiển thị kết quả:**
   - Kết hợp 4 mã LED 7 đoạn vào một thanh ghi 32 bit
   - Dịch mỗi mã vào vị trí bit tương ứng (0, 8, 16, 24)
   - Ghi kết quả vào địa chỉ HEX3_HEX0

5. **Bảng giải mã 7 đoạn:**
   - Chứa các mã để hiển thị số 0-9 trên LED 7 đoạn
   - Vị trí 10-15 được đặt là 0 (không hiển thị gì)

## Phụ lục: Các kiến thức cần thiết

### 1. Cấu trúc mã Assembly RISC-V
- `.section .text`: Phần mã lệnh
- `.section .data`: Phần dữ liệu
- `.equ`: Định nghĩa hằng số
- `.global _start`: Định nghĩa điểm vào của chương trình

### 2. Các lệnh RISC-V thường dùng
- Lệnh đọc/ghi bộ nhớ: `lw`, `sw`, `lh`, `sh`, `lb`, `sb`
- Lệnh số học: `add`, `addi`, `sub`, `subi`
- Lệnh thao tác bit: `and`, `andi`, `or`, `ori`, `slli`, `srli`
- Lệnh rẽ nhánh: `beq`, `bne`, `blt`, `bgt`, `j`, `jal`, `jr`

### 3. Quy ước về thanh ghi
- `x0` hoặc `zero`: Thanh ghi luôn chứa giá trị 0
- `ra`: Địa chỉ trở về (Return Address)
- `sp`: Con trỏ ngăn xếp (Stack Pointer)
- `t0-t6`: Thanh ghi tạm thời (Temporary)
- `s0-s11`:
